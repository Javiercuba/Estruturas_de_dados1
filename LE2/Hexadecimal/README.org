#+title: Hexadecimal
#+author: Javier Ernesto Lopez del real
#+email: javierernesto2000@gmail.com

Explicando o funcionamento do projeto. 

* Função main()
#+begin_src c
int main(void)
{
    node *PILHA = (node *)malloc(sizeof(node));  
    node *invertida = (node *)malloc(sizeof(node)); 
#+end_src c
- Alocando memoria na pilha original e na pilha que será
 invertida e transformada para hexadecimal.

#+begin_src c

    if (!PILHA)
    {
        printf("Sem memoria disponivel!\n");
        exit(1);
    }
}
#+end_src c
- Verifico se tem memoria disponivel.


#+begin_src c

    else
    {
        inicia(PILHA);
        inicia(invertida);
        int opt;

        do
        {
            opt = menu();
            opcao(PILHA, invertida, opt);
        } while (opt);

        free(PILHA);
        return 0;
    }
}
#+end_src c
- Se tiver memoria eu inicio as duas pilhas e abro o menu com a função "opcao".

* Funções "opcao" e "menu"
#+begin_src c
int menu(void)
{
    int opt;

    printf("Escolha a opcao\n");
    printf("0. Sair\n");
    printf("1. Zerar PILHA\n");
    printf("2. Exibir PILHA\n");
    printf("3. PUSH\n");
    printf("4. POP/DESEMPILHAR\n");
    printf("Opcao: ");
    scanf("%d", &opt);

    return opt;
}
#+end_src c


#+begin_src c

void opcao(node *PILHA, node *invertida, int op)
{
    node *tmp;
    switch (op)
    {
    case 0:
        libera(PILHA);
        break;

    case 1:
        libera(PILHA);
        libera(invertida);
        inicia(PILHA);
        inicia(invertida);
        break;

    case 2:
        exibe_int(PILHA);
        break;

    case 3:
        divide(PILHA, 44221);
        exibe_int(PILHA);
        break;

    case 4:
        tmp = pop(PILHA, invertida);
        if (tmp != NULL)
            printf("Retirado/Adicionado: %3d\n\n", tmp->num);
        break;

    default:
        printf("Comando invalido\n\n");
    }
}
#+end_src c
* Explicação de cada caso
** Caso 0 - Libera memoria na pilha original e termina a execução do algoritmo.
#+begin_src c
void opcao(node *PILHA, node *invertida, int op)
{
    node *tmp;
    switch (op)
    {
    case 0:
        libera(PILHA);
        break;
}
#+end_src c

** Caso 1 - Libera memoria na pilha original e na auxiliar e depois zera as duas.
#+begin_src c
void opcao(node *PILHA, node *invertida, int op)
{
    node *tmp;
    switch (op)
    {
     case 1:
        libera(PILHA);
        libera(invertida);
        inicia(PILHA);
        inicia(invertida);
        break;
}
#+end_src c


** Caso 2 - Mostra na tela a pilha original.
#+begin_src c
void opcao(node *PILHA, node *invertida, int op)
{
    node *tmp;
    switch (op)
    {
    case 2:
        exibe_int(PILHA);
        break;
}
#+end_src c


** Caso 3 - A função "divide" insere na pilha original o resto das divisões.
#+begin_src c
void opcao(node *PILHA, node *invertida, int op)
{
    node *tmp;
    switch (op)
    {
   case 3:
        divide(PILHA, 44221);
        exibe_int(PILHA);
        break;
}
#+end_src c


** Caso 4 - A função "pop" retorna e remove o primeiro elemento da pilha.
#+begin_src c
void opcao(node *PILHA, node *invertida, int op)
{
    node *tmp;
    switch (op)
    {
   case 4:
        tmp = pop(PILHA, invertida);
        if (tmp != NULL)
            printf("Retirado/Adicionado: %3d\n\n", tmp->num);
        break;
}
#+end_src c

#+html: <p align="center"><img src="LE2/Hexadecimal/img/captura.jpg" /></p>
** Caso queira baixar o executável [[https://github.com/Javiercuba/Estruturas_de_dados1/releases/download/1.0/combinacao][Clique aqui]].

    

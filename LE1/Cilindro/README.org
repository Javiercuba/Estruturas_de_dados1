#+title: TAD Cilindro
#+author: Javier Ernesto Lopez del real
#+email: javierernesto2000@gmail.com

Explicando o funcionamento do projeto. 

** Arquivo Cilindro.h
No começo do arquivo, defino a struct Cilindro:

#+begin_src c
typedef struct
{   
  float raio;
  float altura;
} cilindro;
#+end_src c


Crio também struct para os resultados das equações (Depois que eu fiz percebi que não fazia muito sentido)

#+begin_src c
typedef struct
{
    float area_base;
    float area_lateral;
    float area_total;
    float volume;

} formula;
#+end_src c

** Funções Presentes 
   Dentro desse arquivo tenho as seguintes funções 

*** 1. Calcula base do cilindro
Essa função recebe dois parâmetros.
 1. Struct do tipo =cilindro= 
 2. Struct do tipo =formula=
 =formula.base= recebe o resultado do cálculo da base de um cilindro (=raio^2 * pi=)
#+begin_src C
int calcula_base(cilindro c, formula *p)
{
    (*p).area_base = c.raio * c.raio * 3.14;
}
#+end_src C



*** 2. Calcula área lateral do cilindro
Essa função recebe dois parâmetros, um é o struct do tipo =cilindro= e o outro é struct do tipo =formula=,
Aqui =formula.area_lateral= vai receber o resultado desse cálculo(=raio * pi * altura=)
#+begin_src c++
int calcula_lateral(cilindro c, formula *p)
{
    (*p).area_lateral = c.raio * 3.14 * c.altura;
}
#+end_src c++


*** 3. Calcula volume do cilindro
Essa função recebe dois parâmetros, um é o struct do tipo =cilindro= e o outro é struct do tipo =formula=,
Aqui =formula.volume= vai receber o resultado desse cálculo(=raio^2 * pi * altura=)
#+begin_src C
int calcula_volume(cilindro c, formula *p)
{
    (*p).volume = c.raio * c.raio * 3.14 * c.altura;
}
#+end_src C


*** 4. Calcula área total do cilindro
Essa função recebe um parâmetro, struct do tipo =formula=,
Aqui =formula.area_total= vai receber o 
resultado o seguinte cálculo - =(2 * Area da base) +(2 * Area Lateral)=
#+begin_src C
int calcula_area_total(formula *p)
{
    (*p).area_total = (2 * (*p).area_base) + (2 * (*p).area_lateral);
}
#+end_src C


*** 5. Atribuindo valores ao cilindro
Essa função recebe três parâmetros, um struct do tipo =cilindro=,duas variáveis do tipo =int=, uma representando o =raio= e a outra a =altura=
Aqui =cilindro.raio= e =cilindro.altura= recebem valores ao cilindro

#+begin_src C
void atribui_valores(cilindro *c, int raio, int altura)
{
    (*c).raio = raio;
    (*c).altura = altura;
}

#+end_src C



*** 5. Imprimindo os valores da area e volume do cilindro
Essa função recebe um parâmetros, um struct do tipo =formula=, onde eu printo a =formula.area_total= e o =formula.volume=

#+begin_src C
void ImprimeResultado(formula resultado)
{
    printf("Area do Cilindro = %.2f\n", resultado.area_total);
    printf("Volume do Cilindro = %.2f\n", resultado.volume);
}
#+end_src C








** Implementação
   Primeiro, defino o =TAD= e seus construtores de tipos:

   #+begin_src haskell
     type Altura = Double
     type Raio = Double
     type Area = Double
     type Volume = Double

     data Cilindro = Vazio | Cilindro { raio :: Raio
				      , altura :: Altura
				      } deriving (Show, Eq)
  #+end_src

   Nas primeiras linhas, defino apelidos para o tipo =Double= para deixar mais legível as implementações.
   Após isso, defino de fato o =TAD=, que possui 2 construtores de tipo:
   1. =Vazio= -> representa um =Cilindro= não definido ou "inválido" matematicamente
   2. =Cilindro= -> o =Cilindro= de fato, que possui um raio e uma altura

   Digo que esse TAD deriva das classes de tipo, =Show=, =Eq= e =Ord=. Em outras palavras,
   isso me permite, respectivamente:
   - Imprimir na tela um =TAD Cilindro=
   - Verificar se um =Cilindro= é igual ou diferente de outro

*** Funções principais
    Essas são as funções explicitamente pedididas no exercício:

    Funções que lidam com um =Cilindro= vazio
    #+begin_src haskell
vazio :: Cilindro
vazio = Vazio

isVazio :: Cilindro -> Bool
isVazio Vazio = True
isVazio _     = False
    #+end_src

    Funções para recuperar apenas a =Altura= ou apenas o =Raio= de um =Cilindro=. Utilizo a Mônada =Maybe=

    Na Filosofia uma Mônada, do grego =monas "unit"=, é uma substância individualmente elementar que reflete
    uma dada ordem do mundo da qual propriedades materiais são derivados.

    Já na Programação Funcional, uma Mônada é uma abstração que permite estruturar programas de forma genérica.
    Essa abstração é utilizada para evitar código clichê necessário para a lógica do programa.

    Neste caso, a Mônada =Maybe= possui dois construtores: =Nothing= e =Just <value>=.

    O =Nothing= representa o vazio, ou que algum processamento falhou, porém não há necessidade de lançar uma exeção
    ou parar o programa por inteiro.

    Já o =Just <value>= envolve um valor que foi corretamente computado e significa que houve êxito.
    #+begin_src haskell
getAltura :: Cilindro -> Maybe Altura
getAltura Vazio          = Nothing
getAltura (Cilindro _ a) = Just a

getRaio :: Cilindro -> Maybe Raio
getRaio Vazio          = Nothing
getRaio (Cilindro r _) = Just r
    #+end_src

    O cálculo da área de um =Cilindro= é definido por: ~A = 2πr^2 + h(2πr)~. Isolando o termo em comum,
    a fórmula pode ser simplificada, resultando em: ~A = 2πr(r + h)~
    #+begin_src haskell
calcArea :: Cilindro -> Maybe Area
calcArea Vazio          = Nothing
calcArea (Cilindro r a) = Just area
  where area = (*) (r + a) . twice $ (*) pi r
    #+end_src

    Já o cálculo do volume de um =Cilindro= é definido por: ~V = πr^2h~
    #+begin_src haskell
calcVolume :: Cilindro -> Maybe Volume
calcVolume Vazio          = Nothing
calcVolume (Cilindro r a) = Just volume
  where volume = pi * (r * r) * a
    #+end_src

*** Funções de ajuda
    Funções para se adequar aos padrões da linguagem, oferecer uma compatibilidade
    entre outras estruturas de dados ou que tornam a implementação das funções principais
    mais legível.

    Funções que convertem de um =2d-Tupla=, ou =Par= de =Double= para um =Cilindro= ou
    vice-versa
    #+begin_src haskell
fromTuple :: (Double, Double) -> Cilindro
fromTuple (r, a) = Cilindro r a

toTuple :: Cilindro -> Maybe (Double, Double)
toTuple Vazio          = Nothing
toTuple (Cilindro r a) = Just (r, a)
    #+end_src

    Apenas uma função que dobra o parâmetro
    #+begin_src haskell
twice :: Floating a => a -> a
twice x = 2 * x
    #+end_src
